name: CI/Scans Pipeline
on:
  pull_request:
    branches:
      - dev

jobs:
  build-and-scan:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write # Required for CodeQL to upload results
      pull-requests: write # Required for posting comments on PR
      actions: read       # Required for CodeQL to access workflow run information

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fixes shallow clone warning - fetches full git history
        token: ${{ secrets.GITHUB_TOKEN }}  # Ensures proper access for blame information

    # --- OWASP Dependency Check (Comprehensive) ---
    - name: OWASP Dependency Check
      id: owasp_check
      uses: dependency-check/Dependency-Check_Action@main
      continue-on-error: true
      with:
        project: 'security-scan'
        path: '.'
        format: 'ALL'  # Generates ALL formats
        out: './owasp-reports'
        args: '--enableRetired --enableExperimental --failOnCVSS 7.0'

    - name: Process OWASP Results
      id: process_owasp
      if: always()
      run: |
        echo "Processing OWASP Dependency Check results..."
        
        # Initialize status as unknown
        echo "owasp_status=unknown" >> $GITHUB_OUTPUT
        
        if [ -f "./owasp-reports/dependency-check-report.json" ]; then
          echo "âœ… OWASP JSON report found, parsing results..."
          
          # Check if jq is available
          if command -v jq >/dev/null 2>&1; then
            # Count total vulnerabilities - handle empty arrays properly
            VULN_COUNT=$(jq '[.dependencies[]? | select(.vulnerabilities != null) | .vulnerabilities[]] | length' ./owasp-reports/dependency-check-report.json 2>/dev/null || echo "0")
            HIGH_VULN_COUNT=$(jq '[.dependencies[]? | select(.vulnerabilities != null) | .vulnerabilities[] | select((.cvssv3?.baseScore // 0) >= 7.0 or (.cvssv2?.score // 0) >= 7.0)] | length' ./owasp-reports/dependency-check-report.json 2>/dev/null || echo "0")
            
            echo "Found $VULN_COUNT total vulnerabilities"
            echo "Found $HIGH_VULN_COUNT high/critical vulnerabilities"
            
            if [ "$VULN_COUNT" -gt 0 ]; then
              if [ "$HIGH_VULN_COUNT" -gt 0 ]; then
                echo "owasp_status=failed" >> $GITHUB_OUTPUT
                echo "âŒ Found $VULN_COUNT total vulnerabilities ($HIGH_VULN_COUNT high/critical):" > owasp_result.txt
              else
                echo "owasp_status=warning" >> $GITHUB_OUTPUT
                echo "âš ï¸ Found $VULN_COUNT low/medium vulnerabilities:" > owasp_result.txt
              fi
              echo "" >> owasp_result.txt
              
              # List vulnerable dependencies with better error handling
              jq -r '.dependencies[]? | select(.vulnerabilities != null and (.vulnerabilities | length > 0)) | "ðŸ“¦ " + .fileName + "\n" + (.vulnerabilities[] | "  â””â”€ " + .name + " (CVSS: " + ((.cvssv3?.baseScore // .cvssv2?.score // "Unknown") | tostring) + ")")' ./owasp-reports/dependency-check-report.json >> owasp_result.txt 2>/dev/null || echo "  â””â”€ Error parsing vulnerability details" >> owasp_result.txt
            else
              echo "owasp_status=passed" >> $GITHUB_OUTPUT
              echo "âœ… No vulnerabilities detected in dependencies" > owasp_result.txt
            fi
          else
            echo "âš ï¸ jq not available for parsing"
            echo "owasp_status=unknown" >> $GITHUB_OUTPUT
            echo "âš ï¸ Could not parse OWASP report (jq not available)" > owasp_result.txt
          fi
        else
          echo "âŒ OWASP JSON report not found at ./owasp-reports/dependency-check-report.json"
          echo "ðŸ“ Checking available files:"
          find ./owasp-reports -name "*.json" -type f 2>/dev/null | head -10 || echo "No JSON files found"
          find ./owasp-reports -name "*.html" -type f 2>/dev/null | head -5 || echo "No HTML files found"
          echo "owasp_status=unknown" >> $GITHUB_OUTPUT
          echo "âš ï¸ OWASP report not generated" > owasp_result.txt
        fi

    # --- Upload OWASP Reports as Artifacts ---
    - name: Upload OWASP Reports
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: owasp-dependency-html-report
        path: ./owasp-reports/dependency-check-report.html
        retention-days: 7

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '22'

    # - name: Set up AWS CLI
    #   uses: aws-actions/configure-aws-credentials@v4
    #   with:
    #     aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
    #     aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
    #     aws-region: ${{ secrets.AWS_REGION }}

    - name: Install pnpm globally
      run: npm install -g pnpm

    # - name: Install co-dependencies
    #   run: yarn co:login

    - name: Install dependencies
      run: pnpm install

    # --- Code Quality Checks ---
    - name: Check If Code Builds
      id: code_build
      continue-on-error: true
      run: |
        # Build code and capture both output and exit code
        set +e  # Don't exit on error
        pnpm build > code_output.txt 2>&1
        BUILD_EXIT_CODE=$?
        set -e  # Re-enable exit on error
        
        # Check the actual exit code, not the tee command
        if [ $BUILD_EXIT_CODE -eq 0 ]; then
          echo "âœ… Code Built successfully"
          echo "code_status=passed" >> $GITHUB_OUTPUT
          echo "âœ… Code Built successfully" > code_result.txt
          echo "" >> code_result.txt
          cat code_output.txt >> code_result.txt
        else
          echo "âŒ Code has build issues"
          echo "code_status=failed" >> $GITHUB_OUTPUT
          echo "âŒ Code has build issues:" > code_result.txt
          echo "" >> code_result.txt
          cat code_output.txt >> code_result.txt
        fi

    - name: Lint with ESLint
      id: eslint_lint
      continue-on-error: true
      run: |
        # Run eslint and capture both output and exit code
        set +e  # Don't exit on error
        pnpm lint > eslint_output.txt 2>&1
        ESLINT_EXIT_CODE=$?
        set -e  # Re-enable exit on error
        
        # Check the actual exit code, not the tee command
        if [ $ESLINT_EXIT_CODE -eq 0 ]; then
          echo "âœ… ESLint passed successfully"
          echo "eslint_status=passed" >> $GITHUB_OUTPUT
          echo "âœ… ESLint passed successfully" > eslint_result.txt
          echo "" >> eslint_result.txt
          cat eslint_output.txt >> eslint_result.txt
        else
          echo "âŒ ESLint found linting issues"
          echo "eslint_status=failed" >> $GITHUB_OUTPUT
          echo "âŒ ESLint found linting issues:" > eslint_result.txt
          echo "" >> eslint_result.txt
          cat eslint_output.txt >> eslint_result.txt
        fi

    - name: Check formatting with Prettier
      id: prettier_format
      continue-on-error: true
      run: |
        # Run prettier and capture both output and exit code
        set +e  # Don't exit on error
        pnpm format:check > prettier_output.txt 2>&1
        PRETTIER_EXIT_CODE=$?
        set -e  # Re-enable exit on error
        
        # Check the actual exit code
        if [ $PRETTIER_EXIT_CODE -eq 0 ]; then
          echo "âœ… Prettier formatting check passed successfully"
          echo "prettier_status=passed" >> $GITHUB_OUTPUT
          echo "âœ… Prettier formatting check passed successfully" > prettier_result.txt
          echo "" >> prettier_result.txt
          cat prettier_output.txt >> prettier_result.txt
        else
          echo "âŒ Prettier formatting issues found"
          echo "prettier_status=failed" >> $GITHUB_OUTPUT
          echo "âŒ Prettier formatting issues found. Run 'prettier .' to fix:" > prettier_result.txt
          echo "" >> prettier_result.txt
          cat prettier_output.txt >> prettier_result.txt
        fi

    # --- Run Tests ---
    # - name: Run Test with Jest
    #   id: jest_tests
    #   continue-on-error: true
    #   run: |
    #     # Run jest and capture both output and exit code
    #     # Cleanup
    #     rm -f jest_output.txt jest_result.txt coverage/lcov.info
    #     set +e  # Don't exit on error

    #     pnpm test:cov > jest_output_raw.txt 2>&1
    #     JEST_EXIT_CODE=$?

    #     # Clean ANSI escape sequences from output
    #     sed 's/\x1b\[[0-9;]*m//g' jest_output_raw.txt > jest_output.txt

    #     set -e  # Re-enable exit on error
        
    #     # Check the actual exit code
    #     if [ $JEST_EXIT_CODE -eq 0 ]; then
    #       echo "âœ… All tests passed successfully!"
    #       echo "jest_status=passed" >> $GITHUB_OUTPUT
    #       echo "âœ… All tests passed successfully!" > jest_result.txt
    #       echo "" >> jest_result.txt

    #       # Include the full output (test results + coverage summary)
    #       cat jest_output.txt >> jest_result.txt
    #     else
    #       echo "âŒ Some tests failed"
    #       echo "jest_status=failed" >> $GITHUB_OUTPUT
    #       echo "âŒ Some tests failed:" > jest_result.txt
    #       echo "" >> jest_result.txt
    #       cat jest_output.txt >> jest_result.txt
    #     fi

    #     # Check if LCOV report was generated for SonarQube
    #     if [ -f "coverage/lcov.info" ]; then
    #       echo "âœ… LCOV coverage report generated for SonarQube: coverage/lcov.info"
    #     else
    #       echo "âš ï¸ LCOV coverage report not found at coverage/lcov.info"
    #     fi

    # --- Run Sonarqube Analysis ---
    - name: Run Sonarqube Scan
      id: sonar_scan
      continue-on-error: true
      uses: sonarsource/sonarqube-scan-action@master
      env:
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}

    # --- Process SonarQube Results  ---
    - name: Process SonarQube Results
      id: process_sonarqube
      if: always()
      continue-on-error: true
      run: |
        echo "Processing SonarQube results..."
        
        # Initialize status as unknown
        echo "sonar_status=unknown" >> $GITHUB_OUTPUT
        echo "sonar_coverage=N/A" >> $GITHUB_OUTPUT
        echo "sonar_bugs=N/A" >> $GITHUB_OUTPUT
        echo "sonar_code_smells=N/A" >> $GITHUB_OUTPUT
        echo "sonar_security_hotspots=N/A" >> $GITHUB_OUTPUT
        echo "sonar_vulnerabilities=N/A" >> $GITHUB_OUTPUT
        echo "sonar_quality_gate=N/A" >> $GITHUB_OUTPUT
        
        # Check if scanner work directory exists
        if [ -f ".scannerwork/report-task.txt" ]; then
          echo "âœ… SonarQube report found, extracting information..."
          
          # Extract task ID and server URL from report
          TASK_ID=$(grep "ceTaskId=" .scannerwork/report-task.txt | cut -d'=' -f2)
          SERVER_URL=$(grep "serverUrl=" .scannerwork/report-task.txt | cut -d'=' -f2)
          
          echo "Task ID: $TASK_ID"
          echo "Server URL: $SERVER_URL"
          
          # Build proper dashboard URL using project key
          PROJECT_KEY="${{ secrets.SONAR_PROJECT_KEY }}"
          DASHBOARD_URL="${SERVER_URL}/dashboard?id=${PROJECT_KEY}"
          
          echo "Dashboard URL: $DASHBOARD_URL"
          
          # Store dashboard URL for comment
          echo "sonar_dashboard_url=$DASHBOARD_URL" >> $GITHUB_OUTPUT
          
          # Wait a bit for SonarQube to process (alternative to quality gate action)
          echo "Waiting for SonarQube analysis to complete..."
          sleep 30
          
          # Try to get analysis results via SonarQube Web API
          if command -v curl >/dev/null 2>&1; then
            echo "Fetching project measures from SonarQube API..."
            
            # Fetch coverage
            COVERAGE_RESPONSE=$(curl -s -u "${{ secrets.SONAR_TOKEN }}:" \
              "$SERVER_URL/api/measures/component?component=$PROJECT_KEY&metricKeys=coverage" 2>/dev/null || echo "")
            
            echo "Coverage API Response: $COVERAGE_RESPONSE"
            
            if echo "$COVERAGE_RESPONSE" | grep -q '"value"'; then
              COVERAGE=$(echo "$COVERAGE_RESPONSE" | sed -n 's/.*"value":"\([^"]*\)".*/\1/p' | head -1)
              if [ "$COVERAGE" != "" ]; then
                echo "sonar_coverage=${COVERAGE}%" >> $GITHUB_OUTPUT
              else
                echo "sonar_coverage=0.0%" >> $GITHUB_OUTPUT
              fi
            else
              echo "sonar_coverage=N/A" >> $GITHUB_OUTPUT
            fi
            
            # Fetch each metric individually for accurate parsing
            echo "Fetching individual metrics..."
            
            # Fetch bugs
            BUGS_RESPONSE=$(curl -s -u "${{ secrets.SONAR_TOKEN }}:" \
              "$SERVER_URL/api/measures/component?component=$PROJECT_KEY&metricKeys=bugs" 2>/dev/null || echo "")
            echo "Bugs API Response: $BUGS_RESPONSE"
            
            if echo "$BUGS_RESPONSE" | grep -q '"value"'; then
              BUGS=$(echo "$BUGS_RESPONSE" | sed -n 's/.*"value":"\([^"]*\)".*/\1/p' | head -1)
              if [ "$BUGS" != "" ]; then
                echo "sonar_bugs=$BUGS" >> $GITHUB_OUTPUT
              fi
            else
              echo "sonar_bugs=0" >> $GITHUB_OUTPUT
              BUGS="0"
            fi
            
            # Fetch code smells
            CODE_SMELLS_RESPONSE=$(curl -s -u "${{ secrets.SONAR_TOKEN }}:" \
              "$SERVER_URL/api/measures/component?component=$PROJECT_KEY&metricKeys=code_smells" 2>/dev/null || echo "")
            echo "Code Smells API Response: $CODE_SMELLS_RESPONSE"
            
            if echo "$CODE_SMELLS_RESPONSE" | grep -q '"value"'; then
              CODE_SMELLS=$(echo "$CODE_SMELLS_RESPONSE" | sed -n 's/.*"value":"\([^"]*\)".*/\1/p' | head -1)
              if [ "$CODE_SMELLS" != "" ]; then
                echo "sonar_code_smells=$CODE_SMELLS" >> $GITHUB_OUTPUT
              fi
            else
              echo "sonar_code_smells=0" >> $GITHUB_OUTPUT
              CODE_SMELLS="0"
            fi
            
            # Fetch vulnerabilities
            VULNERABILITIES_RESPONSE=$(curl -s -u "${{ secrets.SONAR_TOKEN }}:" \
              "$SERVER_URL/api/measures/component?component=$PROJECT_KEY&metricKeys=vulnerabilities" 2>/dev/null || echo "")
            echo "Vulnerabilities API Response: $VULNERABILITIES_RESPONSE"
            
            if echo "$VULNERABILITIES_RESPONSE" | grep -q '"value"'; then
              VULNERABILITIES=$(echo "$VULNERABILITIES_RESPONSE" | sed -n 's/.*"value":"\([^"]*\)".*/\1/p' | head -1)
              if [ "$VULNERABILITIES" != "" ]; then
                echo "sonar_vulnerabilities=$VULNERABILITIES" >> $GITHUB_OUTPUT
              fi
            else
              echo "sonar_vulnerabilities=0" >> $GITHUB_OUTPUT
              VULNERABILITIES="0"
            fi
            
            # Fetch security hotspots
            SECURITY_HOTSPOTS_RESPONSE=$(curl -s -u "${{ secrets.SONAR_TOKEN }}:" \
              "$SERVER_URL/api/measures/component?component=$PROJECT_KEY&metricKeys=security_hotspots" 2>/dev/null || echo "")
            echo "Security Hotspots API Response: $SECURITY_HOTSPOTS_RESPONSE"
            
            if echo "$SECURITY_HOTSPOTS_RESPONSE" | grep -q '"value"'; then
              SECURITY_HOTSPOTS=$(echo "$SECURITY_HOTSPOTS_RESPONSE" | sed -n 's/.*"value":"\([^"]*\)".*/\1/p' | head -1)
              if [ "$SECURITY_HOTSPOTS" != "" ]; then
                echo "sonar_security_hotspots=$SECURITY_HOTSPOTS" >> $GITHUB_OUTPUT
              fi
            else
              echo "sonar_security_hotspots=0" >> $GITHUB_OUTPUT
              SECURITY_HOTSPOTS="0"
            fi
            
            # Get Quality Gate status
            QG_RESPONSE=$(curl -s -u "${{ secrets.SONAR_TOKEN }}:" \
              "$SERVER_URL/api/qualitygates/project_status?projectKey=$PROJECT_KEY" 2>/dev/null || echo "")
            
            echo "Quality Gate API Response: $QG_RESPONSE"
            
            if echo "$QG_RESPONSE" | grep -q '"status"'; then
              QG_STATUS=$(echo "$QG_RESPONSE" | sed -n 's/.*"status":"\([^"]*\)".*/\1/p' | head -1)
              echo "sonar_quality_gate=$QG_STATUS" >> $GITHUB_OUTPUT
              
              if [ "$QG_STATUS" = "OK" ]; then
                echo "sonar_status=passed" >> $GITHUB_OUTPUT
              elif [ "$QG_STATUS" = "ERROR" ]; then
                echo "sonar_status=failed" >> $GITHUB_OUTPUT
              else
                echo "sonar_status=warning" >> $GITHUB_OUTPUT
              fi
            else
              echo "sonar_status=unknown" >> $GITHUB_OUTPUT
            fi
            
            # Get actual values for the summary (now using individual variables)
            ACTUAL_COVERAGE=$(echo "$COVERAGE_RESPONSE" | sed -n 's/.*"value":"\([^"]*\)".*/\1/p' | head -1)
            
            # Add summary to result file
            echo "" >> sonar_result.txt
            echo "ðŸ“Š Analysis Summary:" >> sonar_result.txt
            echo "" >> sonar_result.txt
            echo "| Metric | Value |" >> sonar_result.txt
            echo "|--------|-------|" >> sonar_result.txt
            echo "| ðŸ“Š Coverage | ${ACTUAL_COVERAGE:-N/A}% |" >> sonar_result.txt
            echo "| ðŸ› Bugs | ${BUGS:-0} |" >> sonar_result.txt
            echo "| ðŸ’» Code Smells | ${CODE_SMELLS:-0} |" >> sonar_result.txt
            echo "| ðŸ”“ Vulnerabilities | ${VULNERABILITIES:-0} |" >> sonar_result.txt
            echo "| ðŸ”¥ Security Hotspots | ${SECURITY_HOTSPOTS:-0} |" >> sonar_result.txt
            echo "" >> sonar_result.txt
            echo "ðŸ” [View Full Analysis in SonarQube]($DASHBOARD_URL)" >> sonar_result.txt
            
          else
            echo "âš ï¸ curl not available for API calls"
            echo "sonar_status=unknown" >> $GITHUB_OUTPUT
            echo "âš ï¸ SonarQube analysis completed but could not fetch detailed results" > sonar_result.txt
            echo "ðŸ” View full report: $DASHBOARD_URL" >> sonar_result.txt
          fi
          
        else
          echo "âŒ SonarQube report not found at .scannerwork/report-task.txt"
          echo "sonar_status=failed" >> $GITHUB_OUTPUT
          echo "âŒ SonarQube analysis failed or report not generated" > sonar_result.txt
          echo "Check the SonarQube scan step for errors." >> sonar_result.txt
        fi


    # --- Create PR Comment with Results ---
    - name: Create PR Comment
      if: always()
      run: |
        cat > pr_comment.md << 'EOF'
        ## CI/Scans Pipeline Results ðŸš€
        
        EOF
        
        # Track failures and warnings separately
        HAS_FAILURES=false
        HAS_WARNINGS=false
        FAILED_CHECKS=""
        WARNING_CHECKS=""

        # Code_Build Results
        echo "### ðŸ› ï¸ Code Build Check" >> pr_comment.md
        if [ "${{ steps.code_build.outputs.code_status }}" == "passed" ]; then
          echo "âœ… **Passed** - No Code Build issues found" >> pr_comment.md
        else
          echo "âŒ **Failed** - Code Build issues detected" >> pr_comment.md
          FAILED_CHECKS+="Code_Build, "
          HAS_FAILURES=true
        fi
        echo "" >> pr_comment.md
        echo "<details><summary>ðŸ“„ View Details</summary>" >> pr_comment.md
        echo "" >> pr_comment.md
        echo '```' >> pr_comment.md
        cat code_result.txt >> pr_comment.md
        echo '```' >> pr_comment.md
        echo "</details>" >> pr_comment.md
        echo "" >> pr_comment.md

        # ESLint Results
        echo "### ðŸ” ESLint Linting" >> pr_comment.md
        if [ "${{ steps.eslint_lint.outputs.eslint_status }}" == "passed" ]; then
          echo "âœ… **Passed** - No critical linting issues found" >> pr_comment.md
        else
          echo "âŒ **Failed** - Linting issues detected" >> pr_comment.md
          FAILED_CHECKS+="ESLint, "
          HAS_FAILURES=true
        fi
        echo "" >> pr_comment.md
        echo "<details><summary>ðŸ“„ View Details</summary>" >> pr_comment.md
        echo "" >> pr_comment.md
        echo '```' >> pr_comment.md
        cat eslint_result.txt >> pr_comment.md
        echo '```' >> pr_comment.md
        echo "</details>" >> pr_comment.md
        echo "" >> pr_comment.md

        # Prettier Results
        echo "### ðŸ’… Prettier Formatting" >> pr_comment.md
        if [ "${{ steps.prettier_format.outputs.prettier_status }}" == "passed" ]; then
          echo "âœ… **Passed** - Code formatting is correct" >> pr_comment.md
        else
          echo "âŒ **Failed** - Code formatting issues found" >> pr_comment.md
          FAILED_CHECKS+="Prettier, "
          HAS_FAILURES=true
        fi
        echo "" >> pr_comment.md
        echo "<details><summary>ðŸ“„ View Details</summary>" >> pr_comment.md
        echo "" >> pr_comment.md
        echo '```diff' >> pr_comment.md
        cat prettier_result.txt >> pr_comment.md
        echo '```' >> pr_comment.md
        echo "</details>" >> pr_comment.md
        echo "" >> pr_comment.md

        # # Jest Results
        # echo "### ðŸ§ª Jest Tests" >> pr_comment.md
        # if [ "${{ steps.jest_tests.outputs.jest_status }}" == "passed" ]; then
        #   echo "âœ… **Passed** - All tests are passing" >> pr_comment.md
        # else
        #   echo "âŒ **Failed** - Some tests are failing" >> pr_comment.md
        #   FAILED_CHECKS+="Tests, "
        #   HAS_FAILURES=true
        # fi
        # echo "" >> pr_comment.md
        # echo "<details><summary>ðŸ“„ View Details</summary>" >> pr_comment.md
        # echo "" >> pr_comment.md
        # echo '```' >> pr_comment.md
        # cat jest_result.txt >> pr_comment.md
        # echo '```' >> pr_comment.md
        # echo "</details>" >> pr_comment.md
        # echo "" >> pr_comment.md

        # OWASP Results
        echo "### ðŸ”’ OWASP Dependency Check" >> pr_comment.md
        if [ "${{ steps.process_owasp.outputs.owasp_status }}" == "passed" ]; then
          echo "âœ… **Passed** - No vulnerable dependencies found" >> pr_comment.md
        elif [ "${{ steps.process_owasp.outputs.owasp_status }}" == "warning" ]; then
          echo "âš ï¸ **Warning** - Low/medium severity vulnerabilities found" >> pr_comment.md
          WARNING_CHECKS+="OWASP (Low/Medium), "
          HAS_WARNINGS=true
        elif [ "${{ steps.process_owasp.outputs.owasp_status }}" == "failed" ]; then
          echo "âŒ **Failed** - High/critical vulnerabilities found" >> pr_comment.md
          FAILED_CHECKS+="OWASP (High/Critical), "
          HAS_FAILURES=true
        else
          echo "âš ï¸ **Unknown** - Could not determine vulnerability status" >> pr_comment.md
          WARNING_CHECKS+="OWASP (Unknown), "
          HAS_WARNINGS=true
        fi
        echo "" >> pr_comment.md
        echo "<details><summary>ðŸ“„ View Details</summary>" >> pr_comment.md
        echo "" >> pr_comment.md
        echo '```' >> pr_comment.md
        cat owasp_result.txt >> pr_comment.md
        echo '```' >> pr_comment.md
        echo "" >> pr_comment.md
        echo "ðŸ“Š **Additional Resources:**" >> pr_comment.md
        echo "- [Security Tab](https://github.com/${{ github.repository }}/security/dependabot) - View all dependency alerts" >> pr_comment.md
        echo "- [Dependency Graph](https://github.com/${{ github.repository }}/network/dependencies) - Visual dependency tree" >> pr_comment.md
        echo "- Download full OWASP reports (JSON & HTML) from workflow artifacts" >> pr_comment.md
        echo "</details>" >> pr_comment.md
        echo "" >> pr_comment.md

        # SonarQube Results
        echo "### ðŸ” SonarQube Analysis" >> pr_comment.md
        if [ "${{ steps.process_sonarqube.outputs.sonar_status }}" == "passed" ]; then
          echo "âœ… **SonarQube Quality Gate: PASSED**" >> pr_comment.md
        elif [ "${{ steps.process_sonarqube.outputs.sonar_status }}" == "failed" ]; then
          echo "âŒ **SonarQube Quality Gate: FAILED**" >> pr_comment.md
          FAILED_CHECKS+="SonarQube, "
          HAS_FAILURES=true
        elif [ "${{ steps.process_sonarqube.outputs.sonar_status }}" == "warning" ]; then
          echo "âš ï¸ **SonarQube Quality Gate: WARNING**" >> pr_comment.md
          WARNING_CHECKS+="SonarQube, "
          HAS_WARNINGS=true
        else
          echo "âš ï¸ **Status: UNKNOWN** - Could not determine quality gate status" >> pr_comment.md
          WARNING_CHECKS+="SonarQube (Unknown), "
          HAS_WARNINGS=true
        fi
        
        echo "" >> pr_comment.md
        echo "<details><summary>ðŸ“„ View Details</summary>" >> pr_comment.md
        echo "" >> pr_comment.md
        cat sonar_result.txt >> pr_comment.md
        echo "</details>" >> pr_comment.md
        echo "" >> pr_comment.md

        # Determine overall status based on failures and warnings
        if [ "$HAS_FAILURES" == "true" ]; then
          OVERALL_STATUS="âŒ Failed"
          PIPELINE_STATUS="FAILED"
        elif [ "$HAS_WARNINGS" == "true" ]; then
          OVERALL_STATUS="âš ï¸ Warning"
          PIPELINE_STATUS="WARNING"
        else
          OVERALL_STATUS="âœ… Success"
          PIPELINE_STATUS="SUCCESS"
        fi

        # Overall Status
        echo "---" >> pr_comment.md
        echo "" >> pr_comment.md
        echo "## ðŸ“Š Overall Pipeline Status" >> pr_comment.md
        echo "**Status:** $OVERALL_STATUS" >> pr_comment.md
        echo "" >> pr_comment.md
        
        if [ "$HAS_FAILURES" == "true" ]; then
          FAILED_CHECKS=${FAILED_CHECKS%, }
          echo "**Failed Checks:** $FAILED_CHECKS" >> pr_comment.md
          echo "" >> pr_comment.md
          
          if [ "$HAS_WARNINGS" == "true" ]; then
            WARNING_CHECKS=${WARNING_CHECKS%, }
            echo "**Warnings:** $WARNING_CHECKS" >> pr_comment.md
            echo "" >> pr_comment.md
          fi
          
          echo "### ðŸ”§ Quick Fix Commands" >> pr_comment.md
          echo '```bash' >> pr_comment.md
          echo "# Fix formatting issues" >> pr_comment.md
          echo "yarn format" >> pr_comment.md
          echo "" >> pr_comment.md
          echo "# Run tests locally" >> pr_comment.md
          echo "yarn test:cov" >> pr_comment.md
          echo "" >> pr_comment.md
          echo "# Check linting" >> pr_comment.md
          echo "yarn lint" >> pr_comment.md
          echo "" >> pr_comment.md
          echo "# Check Sonarqube" >> pr_comment.md
          echo "Download Sonarqube lint in your IDE" >> pr_comment.md
          echo '```' >> pr_comment.md
        elif [ "$HAS_WARNINGS" == "true" ]; then
          WARNING_CHECKS=${WARNING_CHECKS%, }
          echo "**Warnings:** $WARNING_CHECKS" >> pr_comment.md
          echo "" >> pr_comment.md
          echo "âš ï¸ This PR has warnings but can proceed with review. Consider addressing the low/medium severity vulnerabilities when possible." >> pr_comment.md
        else
          echo "ðŸŽ‰ **All checks passed!** This PR is ready for review." >> pr_comment.md
        fi
        
        echo "" >> pr_comment.md
        echo "*Generated by CI/Scans Pipeline - $(date)*" >> pr_comment.md

        # Store status for final step
        echo "PIPELINE_STATUS=$PIPELINE_STATUS" >> $GITHUB_ENV

    # --- Post PR Comment ---
    - name: Post PR Comment
      if: always()
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          const comment = fs.readFileSync('pr_comment.md', 'utf8');
          
          const { data: comments } = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
          });
          
          const botComment = comments.find(comment => 
            comment.user.type === 'Bot' && 
            comment.body.includes('CI/Scans Pipeline Results')
          );
          
          if (botComment) {
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: botComment.id,
              body: comment
            });
          } else {
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: comment
            });
          }

    # --- Final Status Check ---
    - name: Final Status Check
      if: always()
      run: |
        if [ "$PIPELINE_STATUS" == "FAILED" ]; then
          echo "Pipeline failed - one or more critical checks failed"
          exit 1
        elif [ "$PIPELINE_STATUS" == "WARNING" ]; then
          echo "Pipeline completed with warnings - review recommended but not blocking"
          exit 0
        else
          echo "Pipeline passed - all checks successful"
          exit 0
        fi